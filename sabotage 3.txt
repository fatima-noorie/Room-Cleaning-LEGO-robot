#pragma config(Sensor, S1,		 downColor,			 sensorCOLORFULL)
#pragma config(Sensor, S3,		 sColor,				 sensorCOLORFULL)
#pragma config(Sensor, S4,		 sonu,					 sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

task main()
{
	bool pickred = false;
	bool pickblue = false;
	bool pickyellow = false;
	bool dropblue = false;
	bool dropred = false;
	bool dropyellow = false;
	float error = 0.0;
	int setvalue = 8;
	bool boxpicked = false;
	int boxesplaced = 0;
	int r = 0;
	int b = 0;
	int y = 0;
	while (true)
	{
		if (SensorValue[downColor] != WHITECOLOR)
		{
			while (SensorValue[sColor] != BLUECOLOR && SensorValue[sColor] != REDCOLOR && SensorValue[sColor] != YELLOWCOLOR && SensorValue[sColor] != GREENCOLOR)
			{
				if (SensorValue[sonu] <= 7 && SensorValue[sonu] >= 7) //In range
				{
					motor [motorB] = 40;	//Go straight
					motor [motorC] = 40;
				}
				else if (SensorValue[sonu] > 7) //Greater range
				{
					error=SensorValue[sonu]-setvalue;
					motor [motorB] = 40+error;	//Turn right
					motor [motorC] = 32-(error/20);
				}
				else if (SensorValue[sonu] < 7)	 //Less range
				{
					motor [motorB] = 32;		 //Turn Left
					motor [motorC] = 40;
				}
				if (SensorValue[sColor] == WHITECOLOR)
				{
					motor [motorB] = -50;
					motor [motorC] = -50;
					wait1Msec(300);
					nMotorEncoderTarget [motorB] = 1050;
					nMotorEncoderTarget [motorC] = 1050;

					motor [motorB] = 0;
					motor [motorC] = 50;
					wait1Msec(1500);
				}
			}



			if (SensorValue[sColor] == REDCOLOR)										 //BOX PICKING for red
			{
				if (boxpicked == false)
				{
					motor [motorB]=0;
					motor [motorC]=0;
					wait1Msec(2000);


					nMotorEncoder[motorB] = 0;	//Going forward slightly
					nMotorEncoder[motorC] = 0;
					nMotorEncoderTarget[motorB] = 60;
					nMotorEncoderTarget[motorC] = 60;

					motor[motorB] = 20; //How fast
					motor[motorC] = 20;

					wait1Msec(5000);
					//Moving left
					nMotorEncoder [motorB] = 0;
					nMotorEncoder [motorC] = 0;

					nMotorEncoderTarget [motorB] = 200;
					nMotorEncoderTarget [motorC] = 200;

					motor [motorB] = -40;
					motor [motorC] = 40;

					wait1Msec(5000);

					//Crane going down
					nMotorEncoder[motorA] = 0;
					nMotorEncoderTarget[motorA] = 1275;
					motor[motorA] = 50;
					wait1Msec(5000);

					//Moving right
					nMotorEncoder [motorB] = 0;
					nMotorEncoder [motorC] = 0;

					nMotorEncoderTarget [motorB] = 275;
					nMotorEncoderTarget [motorC] = 270;

					motor [motorB] = 40;
					motor [motorC] = -40;

					wait1Msec(5000);

					//Crane going up
					nMotorEncoder[motorA] = 0;
					nMotorEncoderTarget[motorA] = 1275;
					motor[motorA] = -50;
					wait1Msec(5000);

					//Moving left again
					nMotorEncoder [motorB] = 0;
					nMotorEncoder [motorC] = 0;

					nMotorEncoderTarget [motorB] = 50;
					nMotorEncoderTarget [motorC] = 50;

					motor [motorB] = -20;
					motor [motorC] = 20;
					wait1Msec(2500);

					r = 1;
					boxpicked = true;
				}
				else
				{
					motor [motorB] =	-50; //turn left to avoid
					motor [motorC] =	-50;
					wait1Msec(300);
					nMotorEncoder[motorB] = 0;
					nMotorEncoder[motorC] = 0;
					nMotorEncoderTarget [motorB] = 0;
					nMotorEncoderTarget [motorC] = 485;

					motor [motorB] = 0;
					motor [motorC] = 50;
					wait1Msec(1000);

					nMotorEncoder[motorB] = 0;	//move forward in that direction
					nMotorEncoder[motorC] = 0;
					nMotorEncoderTarget[motorB] = 1000;
					nMotorEncoderTarget[motorC] = 1000;
					motor[motorB] = 20;
					motor[motorC] = 20;
					wait1Msec(5000);

					motor [motorB] = 0; //turn right to recorrect course
					motor [motorC] = 0;
					wait1Msec(1000);
					nMotorEncoder[motorB] = 0;
					nMotorEncoder[motorC] = 0;
					nMotorEncoderTarget [motorB] = 1250;
					nMotorEncoderTarget [motorC] = 0;

					motor [motorB] = 50;
					motor [motorC] = 0;
					wait1Msec(3000);

					nMotorEncoder[motorB] = 0;	//move forward in that direction
					nMotorEncoder[motorC] = 0;
					nMotorEncoderTarget[motorB] = 400;
					nMotorEncoderTarget[motorC] = 400;
					motor[motorB] = 20;
					motor[motorC] = 20;
					wait1Msec(5000);}

			}
		}

		else if (SensorValue[sColor] == BLUECOLOR)										//BOX PICKING for blue
		{
			if (boxpicked == false)
			{
				motor [motorB]=0;
				motor [motorC]=0;
				wait1Msec(2000);


				nMotorEncoder[motorB] = 0;	//Going forward slightly
				nMotorEncoder[motorC] = 0;
				nMotorEncoderTarget[motorB] = 60;
				nMotorEncoderTarget[motorC] = 60;

				motor[motorB] = 20; //How fast
				motor[motorC] = 20;

				wait1Msec(5000);
				//Moving left
				nMotorEncoder [motorB] = 0;
				nMotorEncoder [motorC] = 0;

				nMotorEncoderTarget [motorB] = 200;
				nMotorEncoderTarget [motorC] = 200;

				motor [motorB] = -40;
				motor [motorC] = 40;

				wait1Msec(5000);

				//Crane going down
				nMotorEncoder[motorA] = 0;
				nMotorEncoderTarget[motorA] = 1275;
				motor[motorA] = 50;
				wait1Msec(5000);

				//Moving right
				nMotorEncoder [motorB] = 0;
				nMotorEncoder [motorC] = 0;

				nMotorEncoderTarget [motorB] = 275;
				nMotorEncoderTarget [motorC] = 270;

				motor [motorB] = 40;
				motor [motorC] = -40;

				wait1Msec(5000);

				//Crane going up
				nMotorEncoder[motorA] = 0;
				nMotorEncoderTarget[motorA] = 1275;
				motor[motorA] = -50;
				wait1Msec(5000);

				//Moving left again
				nMotorEncoder [motorB] = 0;
				nMotorEncoder [motorC] = 0;

				nMotorEncoderTarget [motorB] = 50;
				nMotorEncoderTarget [motorC] = 50;

				motor [motorB] = -20;
				motor [motorC] = 20;
				wait1Msec(2500);

				b = 1;
				boxpicked = true;
			}
			else
			{
				motor [motorB] =	-50; //turn left to avoid
				motor [motorC] =	-50;
				wait1Msec(300);
				nMotorEncoder[motorB] = 0;
				nMotorEncoder[motorC] = 0;
				nMotorEncoderTarget [motorB] = 0;
				nMotorEncoderTarget [motorC] = 485;

				motor [motorB] = 0;
				motor [motorC] = 50;
				wait1Msec(1000);

				nMotorEncoder[motorB] = 0;	//move forward in that direction
				nMotorEncoder[motorC] = 0;
				nMotorEncoderTarget[motorB] = 1000;
				nMotorEncoderTarget[motorC] = 1000;
				motor[motorB] = 20;
				motor[motorC] = 20;
				wait1Msec(5000);

				motor [motorB] = 0; //turn right to recorrect course
				motor [motorC] = 0;
				wait1Msec(1000);
				nMotorEncoder[motorB] = 0;
				nMotorEncoder[motorC] = 0;
				nMotorEncoderTarget [motorB] = 1250;
				nMotorEncoderTarget [motorC] = 0;

				motor [motorB] = 50;
				motor [motorC] = 0;
				wait1Msec(3000);

				nMotorEncoder[motorB] = 0;	//move forward in that direction
				nMotorEncoder[motorC] = 0;
				nMotorEncoderTarget[motorB] = 400;
				nMotorEncoderTarget[motorC] = 400;
				motor[motorB] = 20;
				motor[motorC] = 20;
				wait1Msec(5000);}

		}
	}

	else if (SensorValue[sColor] == YELLOWCOLOR)										 //box picking for yellow
	{
		if (boxpicked == false)
		{
			motor [motorB]=0;
			motor [motorC]=0;
			wait1Msec(2000);


			nMotorEncoder[motorB] = 0;	//Going forward slightly
			nMotorEncoder[motorC] = 0;
			nMotorEncoderTarget[motorB] = 60;
			nMotorEncoderTarget[motorC] = 60;

			motor[motorB] = 20; //How fast
			motor[motorC] = 20;

			wait1Msec(5000);
			//Moving left
			nMotorEncoder [motorB] = 0;
			nMotorEncoder [motorC] = 0;

			nMotorEncoderTarget [motorB] = 200;
			nMotorEncoderTarget [motorC] = 200;

			motor [motorB] = -40;
			motor [motorC] = 40;

			wait1Msec(5000);

			//Crane going down
			nMotorEncoder[motorA] = 0;
			nMotorEncoderTarget[motorA] = 1275;
			motor[motorA] = 50;
			wait1Msec(5000);

			//Moving right
			nMotorEncoder [motorB] = 0;
			nMotorEncoder [motorC] = 0;

			nMotorEncoderTarget [motorB] = 275;
			nMotorEncoderTarget [motorC] = 270;

			motor [motorB] = 40;
			motor [motorC] = -40;

			wait1Msec(5000);

			//Crane going up
			nMotorEncoder[motorA] = 0;
			nMotorEncoderTarget[motorA] = 1275;
			motor[motorA] = -50;
			wait1Msec(5000);

			//Moving left again
			nMotorEncoder [motorB] = 0;
			nMotorEncoder [motorC] = 0;

			nMotorEncoderTarget [motorB] = 50;
			nMotorEncoderTarget [motorC] = 50;

			motor [motorB] = -20;
			motor [motorC] = 20;
			wait1Msec(2500);
			y=1;
			boxpicked=true;

		}
		else
		{
			motor [motorB] =	-50; //turn left to avoid
			motor [motorC] =	-50;
			wait1Msec(300);
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
			nMotorEncoderTarget [motorB] = 0;
			nMotorEncoderTarget [motorC] = 485;

			motor [motorB] = 0;
			motor [motorC] = 50;
			wait1Msec(1000);

			nMotorEncoder[motorB] = 0;	//move forward in that direction
			nMotorEncoder[motorC] = 0;
			nMotorEncoderTarget[motorB] = 1000;
			nMotorEncoderTarget[motorC] = 1000;
			motor[motorB] = 20;
			motor[motorC] = 20;
			wait1Msec(5000);

			motor [motorB] = 0; //turn right to recorrect course
			motor [motorC] = 0;
			wait1Msec(1000);
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
			nMotorEncoderTarget [motorB] = 1250;
			nMotorEncoderTarget [motorC] = 0;

			motor [motorB] = 50;
			motor [motorC] = 0;
			wait1Msec(3000);

			nMotorEncoder[motorB] = 0;	//move forward in that direction
			nMotorEncoder[motorC] = 0;
			nMotorEncoderTarget[motorB] = 400;
			nMotorEncoderTarget[motorC] = 400;
			motor[motorB] = 20;
			motor[motorC] = 20;
			wait1Msec(5000);}

	}

}
else if (SensorValue[sColor] == GREENCOLOR)
{
	if (boxpicked == true)
	{
		//BOX PLACING
		if (r == 1 || y == 1)
		{
			nMotorEncoder[motorB] = 0;	//Reverse movement for placing yellow box
			nMotorEncoder[motorC] = 0;
			nMotorEncoderTarget[motorB] = 400;
			nMotorEncoderTarget[motorC] = 400;
			motor[motorB] = -20;
			motor[motorC] = -20;
			wait1Msec(5000);

			nMotorEncoder[motorA] = 0;	 //Crane down for positioning
			nMotorEncoderTarget[motorA] = 820;
			motor[motorA] = 50;
			wait1Msec(5000);

			nMotorEncoder[motorB] = 0;	//Coming forward to place box
			nMotorEncoder[motorC] = 0;
			nMotorEncoderTarget[motorB] = 475;
			nMotorEncoderTarget[motorC] = 475;
			motor[motorB] = 20;
			motor[motorC] = 20;
			wait1Msec(5000);

			nMotorEncoder[motorA] = 0;	 //Crane down to place box
			nMotorEncoderTarget[motorA] = 275;
			motor[motorA] = 50;
			wait1Msec(5000);

			nMotorEncoder[motorB] = 0;	//Going backward slightly
			nMotorEncoder[motorC] = 0;
			nMotorEncoderTarget[motorB] = 40;
			nMotorEncoderTarget[motorC] = 40;

			motor[motorB] = -20; //How fast
			motor[motorC] = -20;
			wait1Msec(2000);
			nMotorEncoderTarget [motorB] = 1200;
			nMotorEncoderTarget [motorC] = 1200;

			motor [motorB] = -50;
			motor [motorC] = 20;
			wait1Msec(1900);

			nMotorEncoder[motorA] = 0;	 //Crane up to original position
			nMotorEncoderTarget[motorA] = 1095;
			motor[motorA] = -50;
			wait1Msec(5000);

			boxesplaced++;
		}

		else if (b == 1)
		{

			motor [motorB] = 0; //Stop
			motor [motorC] = 0;
			wait1Msec(5000);

			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;	//Clearing the encoders
			nMotorEncoderTarget[motorB] = 75; //How far
			nMotorEncoderTarget[motorC] = 75;

			motor[motorB] = 20; //How fast
			motor[motorC] = 20;

			wait1Msec(5000);


			nMotorEncoder[motorA] = 0;	 //Crane down to place box
			nMotorEncoderTarget[motorA] = 400;
			motor[motorA] = 50;
			wait1Msec(5000);

			nMotorEncoder[motorB] = 0;	//Going backward slightly
			nMotorEncoder[motorC] = 0;
			nMotorEncoderTarget[motorB] = 40;
			nMotorEncoderTarget[motorC] = 40;

			motor[motorB] = -20; //How fast
			motor[motorC] = -20;
			wait1Msec(2000);
			nMotorEncoderTarget [motorB] = 1200;
			nMotorEncoderTarget [motorC] = 1200;

			motor [motorB] = -50;
			motor [motorC] = 20;
			wait1Msec(1900);

			nMotorEncoder[motorA] = 0;	 //Crane up to pos
			nMotorEncoderTarget[motorA] = 400;
			motor[motorA] = -50;
			wait1Msec(5000);
			boxesplaced++;
		}

	}
	else
	{
		//TURN 90 LEFT
		motor [motorB] = -50;
		motor [motorC] = -50;
		wait1Msec(300);
		nMotorEncoderTarget [motorB] = 1050;
		nMotorEncoderTarget [motorC] = 1050;

		motor [motorB] = 0;
		motor [motorC] = 50;
		wait1Msec(1500);
	}
}
}
}
else if (SensorValue[downColor] == WHITECOLOR)
{
//STOP
motor [motorB] = 0;
motor [motorC] = 0;
wait1Msec(1500);
}

}